
# Concept 11.5: Manual Dynamic Memory (The Heap)

## 1. Deep Explanation (The Logic)
So far, every variable we made was stored on the **Stack**.



### The Stack (The Backpack) 
* **Nature:** It is fast and organized, but it is **Small** and **Temporary**.
* **Rule:** When a function ends, the backpack is emptied automatically.

### The Heap (The Warehouse) 
* **Problem:** What if you need to store a Map of the entire building? That is too big for the backpack. You need a Warehouse.
* **Nature:** This is the Warehouse. It is **Huge** and **Permanent**.
* **The Catch:** It is **Manual**. The computer does not clean it for you.
    1.  You must request space (`new`).
    2.  You must manually empty it (`delete`).

---

## 2. Why do we use it?
1.  **Size:** The Stack usually has a limit (e.g., 8MB). If you try to create a massive array (`int data[10000000]`), your program crashes immediately ("Stack Overflow"). The Heap can use all your RAM (GBs).
2.  **Lifetime Control:** Stack variables die when the function returns. If you want to create an object inside a function but keep it alive for the rest of the program, you must put it on the Heap.

---

## 3. Syntax & Rules (`new` & `delete`)

### A. Allocating (Rent the Room)
We use the keyword `new`. It returns a **Pointer** to the address in the Heap.
```cpp
// "Computer, find me space for one int in the Warehouse."
int* ptr = new int(10); 

```

### B. Deallocating (Check Out)

We use the keyword `delete`.

```cpp
// "I am done. You can give this space to someone else."
delete ptr;
ptr = nullptr; // Safety habit

```

### C. Arrays on Heap

```cpp
int* arr = new int[500]; // Array of 500 ints

delete[] arr; // Note the []! Crucial for arrays.

```

---

## 4. The Trap: "The Memory Leak" ⚠️

This is the most dangerous bug in long-running robots.

* **Scenario:** You write a loop that runs 10 times a second. Inside, you write `new LidarScan`. You forget `delete`.
* **Result:** Every second, you steal 10 blocks of RAM and never give them back. After 2 hours, the RAM is full. The OS kills your robot to save itself.

### Trap 2: "Double Free"

If you `delete` the same pointer twice, the program crashes immediately.

---

## 5. Code Example

```cpp
#include <iostream>

void riskyFunction() {
    // 1. Allocate on Heap
    // This variable 'p' lives on the Stack, but it POINTS to the Heap.
    int* p = new int(500); 

    std::cout << "Value: " << *p << "\n";

    // 2. The Danger Zone
    // If we return here, the 'int(500)' remains in RAM forever!
    // return; // <--- MEMORY LEAK

    // 3. Proper Cleanup
    delete p; 
    p = nullptr; // Good practice: ensure we don't use it again.
    
    std::cout << "Memory freed.\n";
}

int main() {
    std::cout << "Start...\n";
    riskyFunction();
    std::cout << "End.\n";
    return 0;
}

```

---

## 6. ROS2 Context: "Why we stopped using this"

In **ROS1** (the old version), developers used `new` and `delete` manually. It caused thousands of bugs where robots would crash after running for 3 days because of a tiny Memory Leak.

In **ROS2**, we adhere to a rule: **"Never use new directly."**

We use **Smart Pointers (Concept 12)** which effectively say:

> *"I will call `new` for you, and I promise to call `delete` automatically when you are done."*

*However, you must understand `new` to understand what Smart Pointers are doing under the hood.*

---

## 7. Task: "The RAM Filler" ✅

**Scenario:**
You need to create a list of numbers, but the size of the list depends on user input (so you can't use a standard array). You must use the Heap.

**Requirements:**

1. Define a pointer `int* database = nullptr;`.
2. **The Logic Puzzle:**
* Allocate an array of 5 integers using `new int[5]`.
* Use a `for` loop to fill them with numbers (0, 10, 20...).
* Print the numbers.
* **Crucial Step:** Delete the memory using `delete[] database`. (If you use just `delete`, it is a bug!).
* Set `database = nullptr`.



**Observation:**
The program should run and exit cleanly.
*If you were to run this in an infinite loop without the `delete[]` line, your computer would eventually freeze. (Don't do that).*
